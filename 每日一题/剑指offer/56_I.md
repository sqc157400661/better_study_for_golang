# 剑指 Offer 56 - I. 数组中数字出现的次数 [中等]

## 题目描述

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

 

### 示例:

```
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]

输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
```

### 限制：

```
2 <= nums.length <= 10000
```

## 知识点：

| 符号 | 描述 | 运算规则                                                     |
| ---- | ---- | ------------------------------------------------------------ |
| &    | 与   | 两个位都为1时，结果才为1                                     |
| \|   | 或   | 两个位都为0时，结果才为0                                     |
| ^    | 异或 | 两个位相同为0，相异为1                                       |
| ~    | 取反 | 0变1，1变0                                                   |
| <<   | 左移 | 各二进位全部左移若干位，高位丢弃，低位补0                    |
| >>   | 右移 | 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移 |

## 解题思路：

由于数组中存在着两个数字不重复的情况，我们将所有的数字异或操作起来，最终得到的结果是这两个数字的异或结果：(相同的两个数字相互异或，值为0)) 最后结果一定不为0，因为有两个数字不重复。

演示：

```
4 ^ 1 ^ 4 ^ 6 => 1 ^ 6

6 对应的二进制： 110
1 对应的二进制： 001
1 ^ 6  二进制： 111
```

我们刚才讲了异或的规律中有一个 任何数和本身异或则为0， 因此我们的思路是能不能将这两个不同的数字分成两组 A 和 B。
分组需要满足两个条件.

- 两个独特的的数字分成不同组

- 相同的数字分成相同组

- 这样每一组的数据进行异或即可得到那两个数字。

  

  问题的关键点是我们怎么进行分组呢？

  由于异或的性质是，同一位相同则为 0，不同则为 1. 我们将所有数字异或的结果一定不是 0，也就是说至少有一位是 1.

  我们随便取一个，分组的依据就来了， 就是你取的那一位是 0 分成 1 组，那一位是 1 的分成一组。
  这样肯定能保证 `2. 相同的数字分成相同组`，不同的数字会被分成不同组么。 很明显当然可以， 因此我们选择是 1，也就是
  说 `要找出的两个不同的的数字` 在那一位一定是不同的，因此两个独特元素一定会被分成不同组。

  


## 复杂度分析：

- 时间复杂度：O(N)，其中N为数组长度。
- 空间复杂度：O(1)



## 代码：

```
func singleNumbers(nums []int) []int {
	// xor用来计算nums的异或和
	xor := 0

	// 计算异或和 并存到xor
	// e.g. [2,4,2,3,3,6] 异或和：(2^2)^(3^3)^(4^6)=2=010
	for i := 0; i < len(nums); i++ {
		xor ^= nums[i]
	}

	//设置mask为1，则二进制为0001
	// mask是一个二进制数，且其中只有一位是1，其他位全是0，
	// 比如000010，表示我们用倒数第二位作为分组标准，倒数第二位是0的数字分到一组，倒数第二位是1的分到另一组
	mask := 1

	// 找到第一位不是0的
	//& operator只有1&1时等于1 其余等于0
	// 用上面的e.g. 4和6的二进制是不同的 我们从右到左找到第一个不同的位就可以分组 4=0100 6=0110
	// 根据e.g. 010 & 001 = 000 = 0则 mask=010
	// 010 & 010 != 0 所以mask=010
	// 之后就可以用mask来将数组里的两个数分区分开
	for (xor & mask) == 0 {
		mask <<= 1
	}

	//两个只出现一次的数字
	a := 0
	b := 0
	for i := 0; i < len(nums); i++ {
		if nums[i]&mask == 0 {
			a ^= nums[i]
		} else {
			b ^= nums[i]
		}
	}
	return []int{a, b}
}
```

## 扩展

题目大意是除了一个数字出现一次，其他都出现了3次or N次，让我们找到出现一次的数。 灵活运用位运算是本题的关键。

我们换一个角度来看，如果数组中没有x，那么数组中所有的数字都出现了3次，在二进制上，每位上1的个数肯定也能被3整除。如{1, 5, 1, 5, 1, 5}从二进制上看有：

```
1：0001
5：0101
1：0001
5：0101
1：0001
5：0101
```

二进制第0位上有6个1，第2位上有3个1.第1位和第3位上都是0个1，每一位上的统计结果都可以被3整除。而**再对该数组添加任何一个数，如果这个数在二进制的某位上为1都将导致该位上1的个数不能被3整除**。因此通过统计二进制上每位1的个数就可以推断出x在该位置上是0还是1了，这样就能计算出x了。

### 代码：

```
// 一个数字出现一次，其他都出现了三次
func singleNumbers(nums []int) int {
	res := 0
	for i:=0; i<32;i++  {
		cnt :=0 // 记录当前 bit 有多少个1
		bit := 1<<i //  记录当前要操作的 bit
		for i := 0; i < len(nums); i++ {
			if nums[i] & bit !=0 {
				cnt++
			}
		}
		// 不等于0说明唯一出现的数字在这个 bit 上是1
		if cnt % 3 != 0{
			res |= bit
		}
	}
	// 负数处理
	if res > int(math.Pow(2,31) - 1) {
		return res - int(math.Pow(2,32))
	}else{
		return res
	}
}
```

