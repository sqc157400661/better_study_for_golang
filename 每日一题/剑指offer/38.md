# 剑指 Offer 38. 字符串的排列

## 题目描述

输入一个字符串，打印出该字符串中字符的所有排列。

 

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。



### 示例:

```
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```

### 限制：

```
1 <= s 的长度 <= 8
```

## 解题思路：

对于一个长度为 n 的字符串（假设字符互不重复），其排列方案数共有：
`n×(n−1)×(n−2)…×2×1`

**排列方案的生成：**

根据字符串排列的特点，考虑深度优先搜索所有排列方案。即通过字符交换，先固定第 1 位字符（n 种情况）、再固定第 2 位字符（n−1 种情况）、... 、最后固定第 n 位字符（ 1 种情况）。

![Picture1.png](http://cdn.xiaot123.com/blog/2021-04/1599403497-KXKQcp-Picture1.png-blog)

**重复排列方案与剪枝**：

当字符串存在重复字符时，排列方案中也存在重复的排列方案。为排除重复方案，需在固定某位字符时，保证 “每种字符只在此位固定一次” ，即遇到重复字符时不交换，直接跳过。从 DFS 角度看，此操作称为 “剪枝” 。

![Picture2.png](http://cdn.xiaot123.com/blog/2021-04/1599403497-GATdFr-Picture2.png-blog)

**递归解析：**

- **终止条件**： 当 `x = len(c) - 1` 时，代表所有位已固定（最后一位只有 1 种情况），则将当前组合 c 转化为字符串并加入 res ，并返回；
- **递推参数**： 当前固定位 x ；
- **递推工作**： 初始化一个 Set ，用于排除重复的字符；将第 x 位字符与 `i∈[x, len(c)]` 字符分别交换，并进入下层递归；
  - 剪枝： 若 `c[i]` 在 Set 中，代表其是重复字符，因此 “剪枝” ；
  - 将 `c[i]` 加入 Set ，以便之后遇到重复字符时剪枝；
  - 固定字符： 将字符 `c[i]` 和 `c[x]` 交换，即固定 `c[i]` 为当前位字符；
  - 开启下层递归： 调用 `dfs(x + 1)` ，即开始固定第 `x + 1` 个字符；
  - 还原交换： 将字符 `c[i]` 和 `c[x]` 交换（还原之前的交换）；

下图中 `list` 对应文中的列表 `c` 。




## 复杂度分析：

- 时间复杂度 O(N!N) ： N 为字符串 s 的长度；时间复杂度和字符串排列的方案数成线性关系，方案数为 `N×(N−1)×(N−2)…×2×1` ，即复杂度为 `O(N!)` ；字符串拼接操作 `join()` 使用 O(N) ；因此总体时间复杂度为 O(N!N) 。
- 空间复杂度 O(N^2)： 全排列的递归深度为 N ，系统累计使用栈空间大小为 O(N) ；递归中辅助 Set 累计存储的字符数量最多为 `N + (N-1) + ... + 2 + 1 = (N+1)N/2` ，即占用 O(N^2)的额外空间。

## 代码：

```
package main

import (
	"fmt"
)

func permutation(s string) []string {
	res =  []string{}
	r := []byte(s)
	dfs(r,0)
	return res
}

var res []string

func dfs(c []byte,x int){
	// 当 x = len(c) - 1 时，代表所有位已固定（最后一位只有 11 种情况），则将当前组合 c 转化为字符串并加入 res ，并返回
	if x == len(c) -1 {
		res = append(res, string(c))
	}
	dic := map[byte]bool{}
	for i := x; i < len(c); i++{
		if _,ok := dic[c[i]];ok {
			continue // 重复，因此剪枝
		}
		dic[c[i]] = true
		c[i], c[x] = c[x], c[i]  // 交换，将 s[i] 固定在第 x 位
		dfs(c,x + 1)  // 进入下一层递归 开启固定第 x + 1 位字符
		//返回时交换回来，这样保证到达第1层的时候，一直都是abc。这里捋顺一下，开始一直都是abc，那么第一位置总共就3个交换
		//分别是a与a交换，这个就相当于 x = 0, i = 0;
		//     a与b交换            x = 0, i = 1;
		//     a与c交换            x = 0, i = 2;
		//就相当于上图中开始的三条路径
		//第一个元素固定后，每个引出两条路径,
		//     b与b交换            x = 1, i = 1;
		//     b与c交换            x = 1, i = 2;
		//所以，结合上图，在每条路径上标注上i的值，就会非常容易好理解了
		c[i], c[x] = c[x], c[i]  // 恢复交换
	}
}

func main()  {
	fmt.Println(permutation("aab"))
}
```



