# 剑指 Offer 40. 最小的k个数 [简单]

## 题目描述

输入整数数组 `arr` ，找出其中最小的 `k` 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

### 示例:

```
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]

输入：arr = [0,1,2,1], k = 1
输出：[0]
```

### 限制：

```
0 <= k <= arr.length <= 10000
0 <= arr[i] <= 10000
```

## 解题思路：

我们可以借鉴快速排序的思想。

- 每次执行完后都能将数组分成两个部分，小于等于分界值 pivot 的元素的都会被放到数组的左边，大于的都会被放到数组的右边，然后返回分界值的下标。
- 与快速排序不同的是，快速排序会根据分界值的下标递归处理划分的两侧，而这里我们只处理划分的一边。

算法思路：

- 划分数组 arr 的 `[left,right]` 部分，使前 k 小的数在数组的左侧
- 在函数里我们调用快排的划分函数，假设划分函数返回的下标是 pos（表示分界值 pivot 最终在数组中的位置），即 pivot 是数组中第 l 小的数，那么一共会有三种情况：
  - 如果 `l == k`，表示 pivot 就是第 k 小的数，直接返回即可；
  - 如果`k<l`，则最小的 *k* 个数一定都在左侧数组中，我们只需要对左侧数组递归地 即可；
  - 如果 `k>l`，则左侧数组中的 l 个数都属于最小的 k 个数，我们还需要在右侧数组中寻找最小的 `k−m `个数，对右侧数组递归地 即可。

在函数返回后，将前 k 个数放入答案数组返回即可。


## 复杂度分析：

时间复杂度：`O(n) `

空间复杂度：`O(logn)`

## 代码：

```
func getLeastNumbers(arr []int, k int) []int {
	return QuickSort(arr,0,len(arr)-1,k)
}

func QuickSort(arr []int,left int,right int,k int) []int{
	if(left > right){
		return arr;
	}
	key := arr[left] //基准点
	l := left
	r := right
	for l!=r {
	    // 基数在左边先移动右游标。在右边先移动左游标。
		// 移动右边，找到比基准值小的  找到后停止移动
		for arr[r] >= key && l<r{
			r--
		}
		// 移动左边 找个比基准值大的 找到后停止移动
		for arr[l] <= key && l<r{
			l++
		}

		// 左右2边都停止移动后 交换左右标记
		if(l < r){
			t := arr[l]
			arr[l] = arr[r]
			arr[r] = t
		}
	}
	// 左右2边相遇，相遇点于基准点互换
	arr[left] = arr[l];
	arr[l] = key;
	if (k == l) {
		// 正好找到最小的 k(m) 个数
		return arr[:k];
	} else if (k < l) {
		// 最小的 k 个数一定在前 m 个数中，递归划分
		return QuickSort(arr, left, l-1, k);
	} else {
		// 在右侧数组中寻找最小的 k-m 个数
		return QuickSort(arr, l+1, right, k);
	}
}

```

