# 剑指 Offer 56 - II. 数组中数字出现的次数 II [中等]

## 题目描述

在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

### 示例:

```
输入：nums = [3,4,3,3]
输出：4

输入：nums = [9,1,7,9,7,9,7]
输出：1
```

### 限制：

```
1 <= nums.length <= 10000
1 <= nums[i] < 2^31
```

## 解题思路：

题目大意是除了一个数字出现一次，其他都出现了3次or N次，让我们找到出现一次的数。 灵活运用位运算是本题的关键。

我们换一个角度来看，如果数组中没有x，那么数组中所有的数字都出现了3次，在二进制上，每位上1的个数肯定也能被3整除。如{1, 5, 1, 5, 1, 5}从二进制上看有：

```
1：0001
5：0101
1：0001
5：0101
1：0001
5：0101
```

二进制第0位上有6个1，第2位上有3个1.第1位和第3位上都是0个1，每一位上的统计结果都可以被3整除。而**再对该数组添加任何一个数，如果这个数在二进制的某位上为1都将导致该位上1的个数不能被3整除**。因此通过统计二进制上每位1的个数就可以推断出x在该位置上是0还是1了，这样就能计算出x了。


## 复杂度分析：

- 时间复杂度O(N) ： 其中 N 位数组 nums 的长度；遍历数组占用 O(N) ，每轮中的常数个位运算操作占用 O(1)。
- 空间复杂度 O(1)





## 代码：

```
// 一个数字出现一次，其他都出现了三次
func singleNumbers(nums []int) int {
	res := 0
	for i:=0; i<32;i++  {
		cnt :=0 // 记录当前 bit 有多少个1
		bit := 1<<i //  记录当前要操作的 bit
		for i := 0; i < len(nums); i++ {
			if nums[i] & bit !=0 {
				cnt++
			}
		}
		// 不等于0说明唯一出现的数字在这个 bit 上是1
		if cnt % 3 != 0{
			res |= bit
		}
	}
	// 负数处理 0x80000000就是32位中首位为1
	if res^(0x80000000) == 0  {
		return res - int(math.Pow(2,32))
	}else{
		return res
	}
}
```

