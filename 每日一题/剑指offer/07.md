# 剑指 Offer 07. 重建二叉树

## 题目描述

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 

### 示例:

```
例如，给出:
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
```

### 限制：

```
0 <= 节点个数 <= 5000
```

## 解题思路：

**前序遍历性质**： 节点按照 `[ 根节点 | 左子树 | 右子树 ]` 排序。
**中序遍历性质**： 节点按照 `[ 左子树 | 根节点 | 右子树 ]` 排序。

> 以题目示例为例：
>
> - 前序遍历划分 `[ 3 | 9 | 20 15 7 ]`
> - 中序遍历划分 `[ 9 | 3 | 15 20 7 ]`

根据以上性质，可得出以下推论：

- 前序遍历的首元素 为 树的根节点 `node` 的值。
- 在中序遍历中搜索**根节点** `node` 的索引 ，可将 **中序遍历** 划分为 `[ 左子树 | 根节点 | 右子树 ]` 。
- 根据中序遍历中的左 / 右子树的节点数量，可将 **前序遍历** 划分为 `[ 根节点 | 左子树 | 右子树 ]` 。

![Picture1.png](http://cdn.xiaot123.com/blog/2021-04/1603644245-oFksKK-Picture1.png-blog)

> 通过以上三步，可确定 **三个节点** ：1.树的根节点、2.左子树根节点、3.右子树根节点。
> 对于树的左、右子树，仍可使用以上步骤划分子树的左右子树。

以上子树的递推性质是 **分治算法** 的体现，考虑通过递归对所有子树进行划分。

**分治算法解析**：

- **递推参数**： 根节点在前序遍历的索引 `root` 、子树在**中序遍历**的左边界 left 、子树在**中序遍历**的右边界 right；

- **终止条件**： 当 `left > right` ，代表已经越过叶节点，此时返回 `null` ；

- **递推工作**：

  - 建立根节点 `node` ： 节点值为 `preorder[root]` ；

  - 划分左右子树： 查找根节点在中序遍历 `inorder` 中的索引 `i` ；

    > 为了提升效率，本文使用哈希表 `dic` 存储中序遍历的值与索引的映射，查找操作的时间复杂度为 O(1)

  - 构建左右子树： 开启左右子树递归；

  |        | 根节点索引          | 中序遍历左边界 | 中序遍历右边界 |
  | ------ | ------------------- | -------------- | -------------- |
  | 左子树 | root + 1            | left           | i - 1          |
  | 右子树 | i - left + root + 1 | i + 1          | right          |

  >
  > i - left + root + 1含义为 根节点索引 + 左子树长度 + 1

- **返回值**： 回溯返回 `node` ，作为上一层递归中根节点的左 / 右子节点；

(1)

![img](http://cdn.xiaot123.com/blog/2021-04/1603644245-DwefAv-Picture2.png-blog)

(2)

![img](http://cdn.xiaot123.com/blog/2021-04/1603644377-aJTwyJ-Picture3.png-blog)

(3)

![img](http://cdn.xiaot123.com/blog/2021-04/1603644377-rGvUqA-Picture4.png-blog)

(4)

![img](http://cdn.xiaot123.com/blog/2021-04/1603644245-OrFteB-Picture5.png-blog)

(5)

![img](http://cdn.xiaot123.com/blog/2021-04/1603644245-RBtYMS-Picture6.png-blog)

(6)

![img](http://cdn.xiaot123.com/blog/2021-04/1603644245-ZlaMmX-Picture7.png-blog)

(7)

![img](http://cdn.xiaot123.com/blog/2021-04/1603644245-leDZaF-Picture8.png-blog)

(8)

![img](http://cdn.xiaot123.com/blog/2021-04/1603644245-KtWHlj-Picture9.png-blog)

(9)

![img](http://cdn.xiaot123.com/blog/2021-04/1603644245-tYOIfd-Picture10.png-blog)

(10)

![img](http://cdn.xiaot123.com/blog/2021-04/1603644245-IAznrm-Picture11.png-blog)

(11)

![img](http://cdn.xiaot123.com/blog/2021-04/1603644245-oLIgwn-Picture12.png-blog)

## 复杂度分析：

- 时间复杂度 O(N)： 其中 N 为树的节点数量。初始化 HashMap 需遍历 inorder ，占用 O(N) 。递归共建立 N 个节点，每层递归中的节点建立、搜索操作占用 O(1) ，因此使用 O(N) 时间。
- 空间复杂度 O(N)： HashMap 使用 O(N) 额外空间。最差情况下，树退化为链表，递归深度达到 N ，占用 O(N) 额外空间；最好情况下，树为满二叉树，递归深度为logN ，占用 O(logN) 额外空间。



## 代码：

注意：本文方法只适用于 “无重复节点值” 的二叉树。

```
package main

type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
//利用原理,先序遍历的第一个节点就是根。在中序遍历中通过根 区分哪些是左子树的，哪些是右子树的
//左右子树，递归
func buildTree(preorder []int, inorder []int) *TreeNode {
	//标记中序遍历
	dic := map[int]int{}
	for k,v:= range inorder {
		dic[v] = k
	}
	return  recur(0,0,len(inorder) -1,preorder,dic)
}

/**
 * @param pre_root_idx  先序遍历的索引
 * @param in_left_idx  中序遍历的索引
 * @param in_right_idx 中序遍历的索引
 */
func recur(pre_root_idx, in_left_idx, in_right_idx int,preorder []int,in_dic map[int]int) *TreeNode {
	//相等就是自己
	if in_left_idx  > in_right_idx {
		return nil
	}
	//root_idx是在先序里面的
	root := &TreeNode{Val:preorder[pre_root_idx]}

	// 有了先序的,再根据先序的，在中序中获 当前根的索引
	idx := in_dic[preorder[pre_root_idx]]

	//左子树的根节点就是 左子树的(前序遍历）第一个，就是+1,左边边界就是left，右边边界是中间区分的idx-1
	root.Left = recur(pre_root_idx + 1, in_left_idx, idx - 1,preorder,in_dic);
	//由根节点在中序遍历的idx 区分成2段,idx 就是根
	//右子树的根，就是右子树（前序遍历）的第一个,就是当前根节点 加上左子树的数量
	// pre_root_idx 当前的根  左子树的长度 = 左子树的左边-右边 (idx-1 - in_left_idx +1) 。最后+1就是右子树的根了
	root.Right = recur(pre_root_idx + (idx-1 - in_left_idx +1)  + 1, idx + 1, in_right_idx,preorder,in_dic);
	return root
}

```

