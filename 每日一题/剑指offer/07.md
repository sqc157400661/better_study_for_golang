# 剑指 Offer 07. 重建二叉树

## 题目描述

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

 

### 示例:

```
例如，给出:
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]

返回如下的二叉树：
    3
   / \
  9  20
    /  \
   15   7
```

### 限制：

```
0 <= 节点个数 <= 5000
```

## 解题思路：

**前序遍历性质**： 节点按照 `[ 根节点 | 左子树 | 右子树 ]` 排序。
**中序遍历性质**： 节点按照 `[ 左子树 | 根节点 | 右子树 ]` 排序。

> 以题目示例为例：
>
> - 前序遍历划分 `[ 3 | 9 | 20 15 7 ]`
> - 中序遍历划分 `[ 9 | 3 | 15 20 7 ]`

根据以上性质，可得出以下推论：

- 前序遍历的首元素 为 树的根节点 `node` 的值。
- 在中序遍历中搜索**根节点** `node` 的索引 ，可将 **中序遍历** 划分为 `[ 左子树 | 根节点 | 右子树 ]` 。
- 根据中序遍历中的左 / 右子树的节点数量，可将 **前序遍历** 划分为 `[ 根节点 | 左子树 | 右子树 ]` 。

![Picture1.png](D:\www\better_study_for_golang\每日一题\images\1603644245-oFksKK-Picture1.png)

> 通过以上三步，可确定 **三个节点** ：1.树的根节点、2.左子树根节点、3.右子树根节点。
> 对于树的左、右子树，仍可使用以上步骤划分子树的左右子树。

以上子树的递推性质是 **分治算法** 的体现，考虑通过递归对所有子树进行划分。

**分治算法解析**：

- **递推参数**： 根节点在前序遍历的索引 `root` 、子树在**中序遍历**的左边界 left 、子树在**中序遍历**的右边界 right；

- **终止条件**： 当 `left > right` ，代表已经越过叶节点，此时返回 `null` ；

- **递推工作**：

  - 建立根节点 `node` ： 节点值为 `preorder[root]` ；

  - 划分左右子树： 查找根节点在中序遍历 `inorder` 中的索引 `i` ；

    > 为了提升效率，本文使用哈希表 `dic` 存储中序遍历的值与索引的映射，查找操作的时间复杂度为 O(1)

  - 构建左右子树： 开启左右子树递归；

  |        | 根节点索引          | 中序遍历左边界 | 中序遍历右边界 |
  | ------ | ------------------- | -------------- | -------------- |
  | 左子树 | root + 1            | left           | i - 1          |
  | 右子树 | i - left + root + 1 | i + 1          | right          |

  >
  > i - left + root + 1含义为 根节点索引 + 左子树长度 + 1

- **返回值**： 回溯返回 `node` ，作为上一层递归中根节点的左 / 右子节点；

(1)

![img](D:\www\better_study_for_golang\每日一题\images\1603644245-DwefAv-Picture2.png)

(2)

![img](D:\www\better_study_for_golang\每日一题\images\1603644377-aJTwyJ-Picture3.png)

(3)

![img](D:\www\better_study_for_golang\每日一题\images\1603644377-rGvUqA-Picture4.png)

(4)

![img](D:\www\better_study_for_golang\每日一题\images\1603644245-OrFteB-Picture5.png)

(5)

![img](D:\www\better_study_for_golang\每日一题\images\1603644245-RBtYMS-Picture6.png)

(6)

![img](D:\www\better_study_for_golang\每日一题\images\1603644245-ZlaMmX-Picture7.png)

(7)

![img](D:\www\better_study_for_golang\每日一题\images\1603644245-leDZaF-Picture8.png)

(8)

![img](D:\www\better_study_for_golang\每日一题\images\1603644245-KtWHlj-Picture9.png)

(9)

![img](D:\www\better_study_for_golang\每日一题\images\1603644245-tYOIfd-Picture10.png)

(10)

![img](D:\www\better_study_for_golang\每日一题\images\1603644245-IAznrm-Picture11.png)

(11)

![img](D:\www\better_study_for_golang\每日一题\images\1603644245-oLIgwn-Picture12.png)

## 复杂度分析：

- 时间复杂度 O(N)： 其中 N 为树的节点数量。初始化 HashMap 需遍历 inorder ，占用 O(N) 。递归共建立 N 个节点，每层递归中的节点建立、搜索操作占用 O(1) ，因此使用 O(N) 时间。
- 空间复杂度 O(N)： HashMap 使用 O(N) 额外空间。最差情况下，树退化为链表，递归深度达到 N ，占用 O(N) 额外空间；最好情况下，树为满二叉树，递归深度为logN ，占用 O(logN) 额外空间。



## 代码：

注意：本文方法只适用于 “无重复节点值” 的二叉树。

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func buildTree(preorder []int, inorder []int) *TreeNode {

}
```

