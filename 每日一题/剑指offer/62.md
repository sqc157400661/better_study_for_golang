# 剑指 Offer 62. 圆圈中最后剩下的数字 [简单]

## 题目描述

`0,1,,n-1`这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

例如，`0、1、2、3、4`这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是`2、0、4、1`，因此最后剩下的数字是3。

 

### 示例:

```
输入: n = 5, m = 3
输出: 3

输入: n = 10, m = 17
输出: 2
```

### 限制：

```
1 <= n <= 10^5
1 <= m <= 10^6
```

## 解题思路：

### 公式法：

#### 问题转换

既然约塞夫问题就是用人来举例的，那我们也给**每个人一个编号（索引值）**，每个人用**字母**代替

下面这个例子是N=8 m=3的例子

我们定义`F(n,m)`表示最后剩下那个人的索引号，因此我们**只关心最后剩下来这个人的索引号的变化**情况即可

![约瑟夫环1.png](../images/d7768194055df1c3d3f6b503468704606134231de62b4ea4b9bdeda7c58232f4-约瑟夫环1.png-blog)

从8个人开始，每次杀掉一个人，去掉被杀的人，然后把杀掉那个人之后的第一个人作为开头重新编号

- 第一次C被杀掉，人数变成7，D作为开头，（最终活下来的G的编号从6变成3）
- 第二次F被杀掉，人数变成6，G作为开头，（最终活下来的G的编号从3变成0）
- 第三次A被杀掉，人数变成5，B作为开头，（最终活下来的G的编号从0变成3）
- 以此类推，当只剩一个人时，他的编号必定为0！（重点！）

#### 最终活着的人编号的反推

现在我们知道了G的索引号的变化过程，那么我们反推一下
从`N = 7 `到`N = 8` 的过程

如何才能将`N = 7` 的排列变回到`N = 8` 呢？

我们先把被杀掉的C补充回来，然后右移m个人，发现溢出了，再把溢出的补充在最前面

**神奇了** 经过这个操作就恢复了`N = 8 `的排列了！

![约瑟夫环2.png](../images/68509352d82d4a19678ed67a5bde338f86c7d0da730e3a69546f6fa61fb0063c-约瑟夫环2.png-blog)

因此我们可以推出递推公式`f(8,3)=[f(7,3)+3]%8`
进行推广泛化，即`f(n,m)=[f(n−1,m)+m]%n`

#### 递推公式的导出

再把`n=1`这个最初的情况加上，就得到递推公式

![2021.1.7yuesefuhuan](http://cdn.xiaot123.com/blog/2021-04/2021.1.7yuesefuhuan.png-blog)


为了更好理解，这里是拿着约瑟夫环的结论进行举例解释，具体的数学证明请参考维基百科。

#### 参考资料

[约瑟夫环——公式法（递推公式）](https://blog.csdn.net/u011500062/article/details/72855826)


## 复杂度分析：

- 时间复杂度：O*(*n*)，需要求解的函数值有 n个。
- 空间复杂度：O*(1)，只使用常数个变量。



## 代码：

```
// 约瑟夫环问题
func lastRemaining(n int, m int) int {
	pos :=0 // 最终活下来那个人的初始位置
	for i:=2;i<=n;i++{
		pos = (pos + m)%i // 每次循环右移
	}
	return pos
}
```

