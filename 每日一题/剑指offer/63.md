# 剑指 Offer 63. 股票的最大利润

## 题目描述

假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

 

### 示例:

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。

输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

### 限制：

```
0 <= 数组长度 <= 10^5 
```

## 解题思路：

本题可以使用贪婪法来解，也可以使用动态规划，本次重点讲解动态规划法解题

**动态规划解析**：

- **状态定义**： 设动态规划列表dp ，`dp[i]` 代表以`prices[i]` 为结尾的子数组的最大利润（以下简称为 **前 i 日的最大利润** ）。
- **转移方程**： 由于题目限定 “买卖该股票一次” ，因此前 i 日最大利润 `dp[i]` 等于前i−1 日最大利润 `dp[i−1]` 和第i日卖出的最大利润中的最大值。
  - `前i日最大利润 = max(前(i−1)日最大利润,第i日价格−前i日最低价格)`
  - `dp[i]=max(dp[i−1],prices[i]−min(prices[0:i]))`
- **初始状态**： `dp[0]=0` ，即首日利润为 0 ；
- **返回值**： `dp[n−1]` ，其中 n 为 dp 列表长度。

![Picture1.png](D:\www\better_study_for_golang\每日一题\images\4880911383c41712612103c612e390f1ee271e4eb921f22476836dc46aa3a58a-Picture1.png)

**效率优化**：

- **时间复杂度降低**： 前i日的最低价格 `min(prices[0:i])` 时间复杂度为O(i) 。而在遍历 prices 时，可以借助一个变量（记为成本 cost ）每日更新最低价格。优化后的转移方程为：
  `dp[i]=max(dp[i−1],prices[i]−min(cost,prices[i])`
- **空间复杂度降低**： 由于 dp[i] 只与 `dp[i−1]` , prices[i] , cost 相关，因此可使用一个变量（记为利润 `profit` ）代替 dp 列表。优化后的转移方程为：
  `profit=max(profit,prices[i]−min(cost,prices[i])`

![img](D:\www\better_study_for_golang\每日一题\images\e00b79988f82af0b5fb2bcaf6dad138f88d67d046213a78298d788511df8b7fb-Picture7.png)


## 复杂度分析：

- 时间复杂度 O(N) ： 其中 N 为 prices列表长度，动态规划需遍历 prices 。
- 空间复杂度 O(1) ： 变量 cost 和 profit 使用常数大小的额外空间。

## 代码：

```
解法1：贪婪算法：
package main

import "fmt"

// 贪婪算法
func maxProfit(prices []int) int {
	var tmp,res,start int
	for i:=0;i<len(prices);i++{
		tmp = prices[i] -  prices[start]
		if tmp <= 0 {
			start = i
			tmp = 0
		}
		res = max(res,tmp)
	}
	return res
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}

func main() {
	fmt.Println(maxProfit([]int{7,1,5,3,6,4}))
}



解法2：动态规划
package main

import "fmt"

func maxProfit(prices []int) int {
	if len(prices) <=0 {
		return 0
	}
	var profit,cost int
	cost = prices[0]
	for i:=0;i<len(prices);i++{
		if prices[i] < cost{
			cost = prices[i]
		}
		profit = max(profit,prices[i] - cost)
	}
	return profit
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}

func main() {
	fmt.Println(maxProfit([]int{7,1,5,3,6,4}))
}


```

