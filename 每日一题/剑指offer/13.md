# 剑指 Offer 13. 机器人的运动范围

## 题目描述

地上有一个m行n列的方格，从坐标 `[0,0]` 到坐标 `[m-1,n-1]` 。一个机器人从坐标` [0, 0] `的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 `[35, 37] `，因为`3+5+3+7=18`。但它不能进入方格 `[35, 38]`，因为`3+5+3+8=19`。请问该机器人能够到达多少个格子？

 

### 示例:

```
输入：m = 2, n = 3, k = 1
输出：3

输入：m = 3, n = 1, k = 0
输出：1
```

### 限制：

```
1 <= n,m <= 100
0 <= k <= 20
```

## 解题思路：

> 本题与 [矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti-12-ju-zhen-zhong-de-lu-jing-shen-du-yo/) 类似，是典型的搜索 & 回溯问题。在介绍回溯算法算法前，为提升计算效率，首先讲述两项前置工作： **数位之和计算** 、 **可达解分析** 。

数位之和计算：
设一数字 xx ，向下取整除法符号 `// `，求余符号 `⊙` ，则有：

- `x ⊙10` ：得到 x 的个位数字；
- `x/10` ： 令 x 的十进制数向右移动一位，即删除个位数字。

因此，可通过循环求得**数位和 s** ，数位和计算的封装函数如下所示：

```go
func sums(x int) int {
	s:=0
	for x !=0 {
		s += x % 10
		x = x / 10
	}
	return s
}
```

由于机器人每次只能移动一格（即只能从 x 运动至 `x±1`），因此每次只需计算 x 到 `x±1` 的数位和增量。本题说明 `1≤n,m≤100` ，以下公式仅在此范围适用。

**数位和增量公式**： 设 x 的数位和为 `s_x，x+1` 的数位和为 `s_{x+1}`；

- 当 `(x+1)⊙10=0` 时： `s_{x+1} = s_x - 8`，例如 19, 20 的数位和分别为 10,2;
- 当 `(x+1)⊙10 !=0` 时： `s_{x+1} = s_x + 1`，例如1,2 的数位和分别为1,2 。

**可达解分析：**
根据数位和增量公式得知，数位和每逢 **进位** 突变一次。根据此特点，矩阵中 **满足数位和的解** 构成的几何形状形如多个 **等腰直角三角形** ，每个三角形的直角顶点位于 0,10,20,... 等数位和突变的矩阵索引处 。

三角形内的解虽然都满足数位和要求，但由于机器人每步只能走一个单元格，而三角形间不一定是连通的，因此机器人不一定能到达，称之为 **不可达解** ；同理，可到达的解称为 **可达解** （本题求此解） 。

下图例展示了 n,m=20 ， k∈[6,19] 的可达解、不可达解、非解，以及连通性的变化。

（1）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-OdpwLi-Picture1.png)

（2）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-jCBpqd-Picture2.png)

（3）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-aEEvfM-Picture3.png)

（4）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-daxIuh-Picture4.png)

（5）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-HAMNPH-Picture5.png)

（6）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-IUKeMt-Picture6.png)

（7）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-YxlxXI-Picture7.png)

（9）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-JLhUWz-Picture8.png)

根据可达解的结构和连通性，易推出机器人可 **仅通过向右和向下移动，访问所有可达解** 。

- **三角形内部**： 全部连通，易证；
- **两三角形连通处**： 若某三角形内的解为可达解，则必与其左边或上边的三角形连通（即相交），即机器人必可从左边或上边走进此三角形。


![Picture9.png](D:\www\better_study_for_golang\每日一题\images\1603024999-XMpudY-Picture9.png)



## 方法一：深度优先遍历 DFS

- **深度优先搜索**： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。
- **剪枝**： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 可行性剪枝 。

算法解析：

- **递归参数**： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 `si, sj` 。
- **终止条件**： 当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 0 ，代表不计入可达解。
- 递推工作：
  - 标记当前单元格 ：将索引 `(i, j)` 存入 Set `visited` 中，代表此单元格已被访问过。
  - 搜索下一单元格： 计算当前元素的 **下、右** 两个方向元素的数位和，并开启下层递归 。
- **回溯返回值**： 返回 `1 + 右方搜索的可达解总数 + 下方搜索的可达解总数`，代表从本单元格递归搜索的可达解总数。

（1）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-XyKkZo-Picture11.png)

（2）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-eQXMnv-Picture12.png)

（3）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-dXOdEJ-Picture14.png)

（4）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-ApTwow-Picture15.png)

（5）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-krgMMb-Picture16.png)

（6）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-iYtADx-Picture21.png)



### 方法二：广度优先遍历 BFS

- **BFS/DFS** ： 两者目标都是遍历整个矩阵，不同点在于搜索顺序不同。DFS 是朝一个方向走到底，再回退，以此类推；BFS 则是按照“平推”的方式向前搜索。
- **BFS 实现**： 通常利用**队列**实现广度优先遍历。

算法解析：

- **初始化**： 将机器人初始点 (0,0) 加入队列 queue ；
- **迭代终止条件**： queue 为空。代表已遍历完所有可达解。
- 迭代工作：
  - **单元格出队**： 将队首单元格的 `索引、数位和` 弹出，作为当前搜索单元格。
  - **判断是否跳过**： 若 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，执行 continue 。
  - **标记当前单元格** ：将单元格索引 `(i, j)` 存入 Set `visited` 中，代表此单元格 已被访问过 。
  - **单元格入队**： 将当前元素的 **下方、右方** 单元格的 `索引、数位和` 加入 queue 。
- **返回值**： Set `visited` 的长度 `len(visited)` ，即可达解的数量。

（1）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-hEnxrs-Picture23.png)

（2）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-goUtpL-Picture24.png)

（3）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-BwmmIl-Picture25.png)

（4）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-NYKszu-Picture29.png)

（5）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-aMYSTi-Picture30.png)

## 复杂度分析：

> 设矩阵行列数分别为 M,N 。

### 方法一：深度优先遍历 DFS

- 时间复杂度O(MN) ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN) 。
- 空间复杂度 O(MN) ： 最差情况下，Set `visited` 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。

### 方法二：广度优先遍历 BFS

- 时间复杂度O(MN) ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN) 。
- 空间复杂度 O(MN) ： 最差情况下，Set `visited` 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。

## 代码：

方法一：深度优先遍历 DFS

```
package main

import "fmt"

func movingCount(m int, n int, k int) int {
	visited = map[int]bool{}
	return dfs(0, 0, 0, 0, m, n, k)
}

var visited map[int]bool

func dfs(i, j, si, sj, m, n, k int) int {
	key := i*100 + j
	_, ok := visited[key]
	if i >= m || j >= n || k < si+sj || ok {
		return 0
	}
	visited[key] = true
	// 递归下方
	down := dfs(i+1, j, sums(i, si), sj, m, n, k)
	// 递归右方
	right := dfs(i, j+1, si, sums(j, sj), m, n, k)

	return 1 + down + right
}

func main() {
	fmt.Println(movingCount(6, 6, 9))
}

// 数位和增量计算方法 比下面的高效
func sums(x, si int) int {
	if (x+1)%10 != 0 {
		return si + 1
	} else {
		return si - 8
	}
}

func fullSums(x int) int {
	s := 0
	for x != 0 {
		s += x % 10
		x = x / 10
	}
	return s
}
```

方法二：广度优先遍历 BFS

```
package main

import (
	"fmt"
	"sync"
)

// 队列的实现
type queue struct {
	arr [][]int
	sync.RWMutex
}

// 从队列首部加入元素
func (q *queue) DeQue(i, j, si, sj int) {
	defer q.Unlock()
	q.Lock()
	if len(q.arr) == 0 {
		q.arr = [][]int{{i, j, si, sj}}
	} else {
		q.arr = append(q.arr, []int{i, j, si, sj})
	}
}

// 从尾部删除元素
func (q *queue) Pop() []int {
	defer q.Unlock()
	q.Lock()
	if len(q.arr) == 0 {
		return nil
	}
	re := q.arr[0]
	if len(q.arr) >= 1 {
		q.arr = q.arr[1:len(q.arr)]
	}
	return re
}

func (q *queue) len() int {
	return len(q.arr)
}

var visited map[int]bool

func movingCount(m int, n int, k int) int {
	visited = map[int]bool{}
	queue := queue{arr: [][]int{}}
	queue.DeQue(0, 0, 0, 0)
	for queue.len() > 0 {
		item := queue.Pop()
		i, j, si, sj := item[0], item[1], item[2], item[3]
		key := i*100 + j
		_, ok := visited[key]
		if i >= m || j >= n || k < si+sj || ok {
			continue
		}
		visited[key] = true
		// 下面
		queue.DeQue(i+1, j, sums(i, si), sj)
		// 右边
		queue.DeQue(i, j+1, si, sums(j, sj))
	}
	return len(visited)
}

// 数位和增量
func sums(x, si int) int {
	if (x+1)%10 != 0 {
		return si + 1
	} else {
		return si - 8
	}
}

func main() {
	fmt.Println(movingCount(6, 6, 9))
}

```

