# 剑指 Offer 13. 机器人的运动范围

## 题目描述

地上有一个m行n列的方格，从坐标 `[0,0]` 到坐标 `[m-1,n-1]` 。一个机器人从坐标` [0, 0] `的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 `[35, 37] `，因为`3+5+3+7=18`。但它不能进入方格 `[35, 38]`，因为`3+5+3+8=19`。请问该机器人能够到达多少个格子？

 

### 示例:

```
输入：m = 2, n = 3, k = 1
输出：3

输入：m = 3, n = 1, k = 0
输出：1
```

### 限制：

```
1 <= n,m <= 100
0 <= k <= 20
```

## 解题思路：

> 本题与 [矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/solution/mian-shi-ti-12-ju-zhen-zhong-de-lu-jing-shen-du-yo/) 类似，是典型的搜索 & 回溯问题。在介绍回溯算法算法前，为提升计算效率，首先讲述两项前置工作： **数位之和计算** 、 **可达解分析** 。

数位之和计算：
设一数字 xx ，向下取整除法符号 `// `，求余符号 `⊙` ，则有：

- `x ⊙10` ：得到 x 的个位数字；
- `x/10` ： 令 x 的十进制数向右移动一位，即删除个位数字。

因此，可通过循环求得**数位和 s** ，数位和计算的封装函数如下所示：

```go
func sums(x int) int {
	s:=0
	for x !=0 {
		s += x % 10
		x = x / 10
	}
	return s
}
```

由于机器人每次只能移动一格（即只能从 x 运动至 `x±1`），因此每次只需计算 x 到 `x±1` 的数位和增量。本题说明 `1≤n,m≤100` ，以下公式仅在此范围适用。

**数位和增量公式**： 设 x 的数位和为 `s_x，x+1` 的数位和为 `s_{x+1}`；

- 当 `(x+1)⊙10=0` 时： `s_{x+1} = s_x - 8`，例如 19, 20 的数位和分别为 10,2;
- 当 `(x+1)⊙10 !=0` 时： `s_{x+1} = s_x + 1`，例如1,2 的数位和分别为1,2 。

**可达解分析：**
根据数位和增量公式得知，数位和每逢 **进位** 突变一次。根据此特点，矩阵中 **满足数位和的解** 构成的几何形状形如多个 **等腰直角三角形** ，每个三角形的直角顶点位于 0,10,20,... 等数位和突变的矩阵索引处 。

三角形内的解虽然都满足数位和要求，但由于机器人每步只能走一个单元格，而三角形间不一定是连通的，因此机器人不一定能到达，称之为 **不可达解** ；同理，可到达的解称为 **可达解** （本题求此解） 。

下图例展示了 n,m=20 ， k∈[6,19] 的可达解、不可达解、非解，以及连通性的变化。

（1）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-OdpwLi-Picture1.png)

（2）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-jCBpqd-Picture2.png)

（3）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-aEEvfM-Picture3.png)

（4）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-daxIuh-Picture4.png)

（5）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-HAMNPH-Picture5.png)

（6）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-IUKeMt-Picture6.png)

（7）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-YxlxXI-Picture7.png)

（9）

![img](D:\www\better_study_for_golang\每日一题\images\1603026306-JLhUWz-Picture8.png)

根据可达解的结构和连通性，易推出机器人可 **仅通过向右和向下移动，访问所有可达解** 。

- **三角形内部**： 全部连通，易证；
- **两三角形连通处**： 若某三角形内的解为可达解，则必与其左边或上边的三角形连通（即相交），即机器人必可从左边或上边走进此三角形。


![Picture9.png](D:\www\better_study_for_golang\每日一题\images\1603024999-XMpudY-Picture9.png)



## 方法一：深度优先遍历 DFS

- **深度优先搜索**： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。
- **剪枝**： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 可行性剪枝 。

算法解析：

- **递归参数**： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 `si, sj` 。
- **终止条件**： 当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 0 ，代表不计入可达解。
- 递推工作：
  - 标记当前单元格 ：将索引 `(i, j)` 存入 Set `visited` 中，代表此单元格已被访问过。
  - 搜索下一单元格： 计算当前元素的 **下、右** 两个方向元素的数位和，并开启下层递归 。
- **回溯返回值**： 返回 `1 + 右方搜索的可达解总数 + 下方搜索的可达解总数`，代表从本单元格递归搜索的可达解总数。

（1）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-XyKkZo-Picture11.png)

（2）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-eQXMnv-Picture12.png)

（3）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-dXOdEJ-Picture14.png)

（4）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-ApTwow-Picture15.png)

（5）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-krgMMb-Picture16.png)

（6）

![img](D:\www\better_study_for_golang\每日一题\images\1603024999-iYtADx-Picture21.png)

## 复杂度分析：

> 设矩阵行列数分别为 M,N 。

### 方法一：深度优先遍历 DFS

- 时间复杂度O(MN) ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN) 。
- 空间复杂度 O(MN) ： 最差情况下，Set `visited` 内存储矩阵所有单元格的索引，使用 O(MN) 的额外空间。



## 代码：

```

```

