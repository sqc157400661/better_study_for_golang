# 剑指 Offer 31. 栈的压入、弹出序列

## 题目描述

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 `{1,2,3,4,5}` 是某栈的压栈序列，序列 `{4,5,3,2,1}` 是该压栈序列对应的一个弹出序列，但 `{4,3,5,1,2}` 就不可能是该压栈序列的弹出序列。

 

### 示例:

```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1

输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

### 限制：

```
0 <= pushed.length == popped.length <= 1000

0 <= pushed[i], popped[i] < 1000

pushed 是 popped 的排列。
```

## 解题思路：

如下图所示，给定一个压入序列 pushed 和弹出序列 popped，则压入 / 弹出操作的顺序（即排列）是 **唯一确定** 的

![Picture1.png](D:\www\better_study_for_golang\每日一题\images\c880f045c03a8e03b7908b2d49b658a9a32ba8f5d40cb19da62db32c7eb58830-Picture1.png)

如下图所示，栈的数据操作具有 **先入后出** 的特性，因此某些弹出序列是无法实现的。

![Picture2.png](D:\www\better_study_for_golang\每日一题\images\4397f5b44038603d70568147824877cacdaa76cef22371c2c80ff55f915092fd-Picture2.png)

考虑借用一个辅助栈 stack ，**模拟** 压入 / 弹出操作的排列。根据是否模拟成功，即可得到结果。

- **入栈操作**： 按照压栈序列的顺序执行。
- **出栈操作**： 每次入栈后，循环判断 “栈顶元素 == 弹出序列的当前元素” 是否成立，将符合弹出序列顺序的栈顶元素全部弹出。

> 由于题目规定 栈的所有数字均不相等 ，因此在循环入栈中，每个元素出栈的位置的可能性是唯一的（若有重复数字，则具有多个可出栈的位置）。因而，在遇到 “栈顶元素 == 弹出序列的当前元素” 就应立即执行出栈。
>



算法流程：

- **初始化**： 辅助栈 `stack` ，弹出序列的索引 i ；
- **遍历压栈序列**： 各元素记为num；
  - 元素num入栈；
  - 循环出栈：若 stack 的栈顶元素 == 弹出序列元素 popped[i] ，则执行出栈与i++ ；
- **返回值**： 若stack 为空，则此弹出序列合法。

(1)

![img](D:\www\better_study_for_golang\每日一题\images\201e825436b3e28eac363c4d1bf3728a000ec76edd358f4098a5c24534e3ea0c-Picture3.png)

(2)

![img](D:\www\better_study_for_golang\每日一题\images\05948472d4096747117036d4fd7430b817b84cb39946718127c912afe56378d5-Picture4.png)

(3)

![img](D:\www\better_study_for_golang\每日一题\images\ba2f2b776b23d64a539d326fce219345114c26ff3c186388d1c9e2b267e3a6f7-Picture5.png)

(4)

![img](D:\www\better_study_for_golang\每日一题\images\c428090b921067f1c92d3c5e6f9abf45bda55e2ce44e99ecbc7db646251fe9fc-Picture6.png)

(5)

![img](D:\www\better_study_for_golang\每日一题\images\904b2334c1f1f7bc0c93f56e12c061aa69f34468a96c5bd9f50c06fa59e090ad-Picture7.png)

(6)

![img](D:\www\better_study_for_golang\每日一题\images\47909bda13373fab0c98972354bf942f19993776cb04e322a37c197198e0c705-Picture8.png)

(7)

![img](D:\www\better_study_for_golang\每日一题\images\83b13e44ad02b1046351707b7f4fd76bd1fa0d5e0413e8c0bc61fb9f890dad5e-Picture9.png)

(8)

![img](D:\www\better_study_for_golang\每日一题\images\e38264dc425209d2c0aaaab4d6050cd0a3d69d48c4c5877808e30788c752ff53-Picture10.png)

(9)

![img](D:\www\better_study_for_golang\每日一题\images\5c35507c10e3b7745ef769d6a879a28ee186be671daaf3ca75355153dd5543e4-Picture11.png)

(10)

![img](D:\www\better_study_for_golang\每日一题\images\94cddb1d8ac2ec779293b3dc7f18488caf5e23adbc3f14c60d44f7d8bca80c51-Picture12.png)

(11)

![img](D:\www\better_study_for_golang\每日一题\images\958c96bbe4d77e3d0642bb9b13e1aaaeab5564e722b6516314b37a4f0958a209-Picture13.png)

(12)

![img](D:\www\better_study_for_golang\每日一题\images\9181035f31451f0ee53a5892f97e810577f01c4317c5bd9d2518ae335aae2f7e-Picture14.png)




## 复杂度分析：

- 时间复杂度 O(N) ： 其中 N 为列表 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2N 次出入栈操作。
- 空间复杂度 O(N)： 辅助栈stack 最多同时存储 N 个元素。



## 代码：

```
package main

type stack struct{
	arr []int
}
func(s *stack) Push(node int){
	s.arr = append(s.arr,node)
}

func(s *stack) Pop() int{
	if len(s.arr) ==0 {
		return 0
	}
	re := s.arr[len(s.arr)-1]
	if len(s.arr)>1 {
		s.arr =s.arr[0:len(s.arr)-1]
	}else{
		s.arr = nil
	}
	return re
}

func(s *stack) peek() int {
	return s.arr[len(s.arr)-1]
}

func(s *stack) IsEmpty() bool{
	return len(s.arr) ==0
}

func validateStackSequences(pushed []int, popped []int) bool {
	stack := &stack{arr:[]int{}}
	i := 0
	for _,v := range pushed {
		stack.Push(v)
		for !stack.IsEmpty() && stack.peek() == popped[i]{
			stack.Pop()
			i++
		}
	}
	return stack.IsEmpty()
}
```

