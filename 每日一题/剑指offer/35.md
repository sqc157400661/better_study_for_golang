# 剑指 Offer 35. 复杂链表的复制

## 题目描述

请实现 `copyRandomList` 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 `random` 指针指向链表中的任意节点或者 null。

 

### 示例:

示例1：

![img](http://cdn.xiaot123.com/blog/2021-04/e1.png-blog)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

示例 2：

![img](http://cdn.xiaot123.com/blog/2021-04/e2.png-blog)

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

示例 3：

![img](http://cdn.xiaot123.com/blog/2021-04/e3.png-blog)

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

示例 4：

```
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
```

### 限制：

```
-10000 <= Node.val <= 10000
Node.random 为空（null）或指向链表中的节点。
节点数目不超过 1000 。
```

## 解题思路：

给定链表的头节点 head ，复制普通链表很简单，只需遍历链表，每轮建立新节点 + 构建前驱节点 pre 和当前节点 node 的引用指向即可。

本题链表的节点新增了 `random` 指针，指向链表中的 任意节点 或者 `null` 。这个 random 指针意味着在复制过程中，除了构建前驱节点和当前节点的引用指向 `pre.next` ，还要构建前驱节点和其随机节点的引用指向 `pre.random` 。

**本题难点：** 在复制链表的过程中构建新链表各节点的 `random` 引用指向。

![Picture1.png](http://cdn.xiaot123.com/blog/2021-04/1604747285-ELUgCd-Picture1.png-blog)

本文介绍 「哈希表」 ，「拼接 + 拆分」 两种方法。哈希表方法比较直观；拼接 + 拆分方法的空间复杂度更低。

### 方法一：哈希表

利用哈希表的查询特点，考虑构建 **原链表节点** 和 **新链表对应节点** 的键值对映射关系，再遍历构建新链表各节点的 `next` 和 `random` 引用指向即可。

算法流程：

- 若头节点 `head` 为空节点，直接返回`null`；
- 初始化： 哈希表 dic ， 节点 cur 指向头节点；
- 复制链表：
  - 建立新节点，并向 `dic` 添加键值对 (原 `cur` 节点, 新 `cur` 节点） ；
  - cur 遍历至原链表下一节点；
- 构建新链表的引用指向：
  - 构建新节点的 `next` 和 `random` 引用指向；
  - `cur` 遍历至原链表下一节点；
- 返回值： 新链表的头节点 `dic[cur]` ；

(1)

![img](http://cdn.xiaot123.com/blog/2021-04/1604747285-ZidetZ-Picture2.png-blog)

(2)

![img](http://cdn.xiaot123.com/blog/2021-04/1604747285-JWRWlw-Picture3.png-blog)

(3)

![img](http://cdn.xiaot123.com/blog/2021-04/1604747285-YjPYai-Picture6.png-blog)

(4)

![img](http://cdn.xiaot123.com/blog/2021-04/1604747285-gKnCSl-Picture7.png-blog)

(5)

![img](http://cdn.xiaot123.com/blog/2021-04/1604747285-lmVIhC-Picture8.png-blog)

(6)

![img](http://cdn.xiaot123.com/blog/2021-04/1604747285-vDhdiA-Picture12.png-blog)

(7)

![img](http://cdn.xiaot123.com/blog/2021-04/1604747285-bhLYzn-Picture13.png-blog)



### 方法二：拼接 + 拆分

考虑构建 `原节点 1 -> 新节点 1 -> 原节点 2 -> 新节点 2 -> ……` 的拼接链表，如此便可在访问原节点的 `random` 指向节点的同时找到新对应新节点的 `random` 指向节点。

算法流程：

- 复制各节点，构建拼接链表:

  - 设原链表为 `node1→node2→⋯` ，构建的拼接链表如下所示：

    ![1617930744295](http://cdn.xiaot123.com/blog/2021-04/1617930744295.png-blog)

- 构建新链表各节点的`random`指向：

  - 当访问原节点 `cur` 的随机指向节点 `cur.random` 时，对应新节点 `cur.next` 的随机指向节点为 `cur.random.next` 。

- 拆分原 / 新链表：

  - 设置 `pre / cur` 分别指向**原 / 新链表头节点**，遍历执行 `pre.next = pre.next.next` 和 `cur.next = cur.next.next` 将两链表拆分开。

- 返回新链表的头节点 `res` 即可。



(1)

![img](http://cdn.xiaot123.com/blog/2021-04/1604747742-aMDdkM-Picture14.png-blog)

(2)

![img](http://cdn.xiaot123.com/blog/2021-04/1604747285-ADzCgN-Picture15.png-blog)

(3)

![img](http://cdn.xiaot123.com/blog/2021-04/1604747285-PYYwDy-Picture18.png-blog)

(4)

![img](http://cdn.xiaot123.com/blog/2021-04/1604747285-TJdMjI-Picture19.png-blog)

(5)

![img](http://cdn.xiaot123.com/blog/2021-04/1604747285-EMCcno-Picture20.png-blog)



## 复杂度分析：

方法一：哈希表:

- **时间复杂度 O(N)：** 两轮遍历链表，使用 O*(*N) 时间。
- **空间复杂度 O(N)：** 哈希表 `dic` 使用线性大小的额外空间。

方法二：拼接 + 拆分:

- **时间复杂度 O(N) ：** 三轮遍历链表，使用O*(*N) 时间。
- **空间复杂度 O(1) ：** 节点引用变量使用常数大小的额外空间。



## 代码：

```
// 方法一：哈希表
package main

type Node struct {
	Val  int
	Next *Node
	Random *Node
}

func copyRandomList(head *Node) *Node {
	if head == nil{
		return nil
	}
	dic := map[*Node]*Node{}
	cur := head
	// 复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
	for cur != nil {
		dic[cur] = &Node{Val:cur.Val}
		cur = cur.Next
	}
	cur = head
	// 构建新链表的 next 和 random 指向
	for cur != nil {
		dic[cur].Next = dic[cur.Next]
		dic[cur].Random = dic[cur.Random]
		cur = cur.Next
	}
	// 返回新链表的头节点
	return dic[head]
}


// 方法二：拼接 + 拆分:
package main

type Node struct {
	Val  int
	Next *Node
	Random *Node
}

/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Next *Node
 *     Random *Node
 * }
 */

func copyRandomList(head *Node) *Node {
	if head == nil{
		return nil
	}
	cur := head
	// 1. 复制各节点，并构建拼接链表
	for cur != nil {
		tmp := &Node{Val:cur.Val}
		tmp.Next = cur.Next
		cur.Next = tmp
		cur = tmp.Next
	}
	// 2. 构建各新节点的 random 指向
	cur = head
	for cur != nil {
		if cur.Random !=nil {
			cur.Next.Random = cur.Random.Next
		}
		cur = cur.Next.Next
	}
	// 3. 拆分两链表
	pre := head
	cur = head.Next
	res := head.Next
	
	for cur.Next != nil{
		pre.Next = pre.Next.Next
		cur.Next = cur.Next.Next
		pre = pre.Next
		cur = cur.Next
	}
	pre.Next = nil // 单独处理原链表尾节点
	return res      // 返回新链表头节点
}
```

