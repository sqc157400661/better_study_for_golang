# 剑指 Offer 26. 树的子结构

## 题目描述

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

```
给定的树 A:

     3
    / \
   4   5
  / \
 1   2
 
给定的树 B：

   4 
  /
 1
 
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
```

### 示例:

```
输入：A = [1,2,3], B = [3,1]
输出：false

输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```

### 限制：

```
0 <= 节点个数 <= 10000
```

## 解题思路：

解题思路：

若树B是树A的子结构，则子结构的根节点可能为树A的任意一个节点。因此，判断树B是否是树A的子结构，需完成以下两步工作：

- 先序遍历树 A 中的每个节点 n_A；（对应函数 `isSubStructure(A, B)`）
- 判断树 A 中 **以 n_A为根节点的子树** 是否包含树 B 。（对应函数 `recur(A, B)`）

![Picture1.png](D:\www\better_study_for_golang\每日一题\images\27d9f65b79ae4982fb58835d468c2a23ec2ac399ba5f38138f49538537264d03-Picture1.png)

##### 算法流程：

> 名词规定：**树 A** 的根节点记作 **节点 A** ，**树 B** 的根节点称为 **节点 B** 。

`recur(A, B)` 函数：

- **终止条件**：
  - 当节点 B 为空：说明树 B 已匹配完成（越过叶子节点），因此返回true ；
  - 当节点 A 为空：说明已经越过树 AA 叶子节点，即匹配失败，返回 false ；
  - 当节点 A 和 B 的值不同：说明匹配失败，返回 false；
- **返回值**：
  - 判断 A 和 B 的左子节点是否相等，即 `recur(A.left, B.left)` ；
  - 判断 A 和 B 的右子节点是否相等，即 `recur(A.right, B.right)` ；

`isSubStructure(A, B)` 函数：

- 特例处理： 当 树 A 为空 或 树 B 为空 时，直接返回 false ；
- 返回值： 若树 B 是树 A 的子结构，则必满足以下三种情况之一，因此用或 `||` 连接；
  - 以 节点 A 为根节点的子树 包含树 B ，对应 `recur(A, B)`；
  - 树 B 是 树 A 左子树 的子结构，对应 `isSubStructure(A.left, B)`；
  - 树 B 是 树 A 右子树 的子结构，对应 `isSubStructure(A.right, B)`；
    以上 2. 3. 实质上是在对树 AA 做 先序遍历 。

（1）

![img](D:\www\better_study_for_golang\每日一题\images\0e15908809807327aa87c748c4cf1d850eeb63cc13df94c87439cbaffb535005-Picture2.png)

（2）

![img](D:\www\better_study_for_golang\每日一题\images\5d9592ec644c6fc765d6e223d4beb3a74ecf46a32b703d9d02cdbeb9f88e9523-Picture3.png)

（3）

![img](D:\www\better_study_for_golang\每日一题\images\76016cb01f7c051318761388eeadd774b334c6da3c5722754452fc82da87c04b-Picture4.png)

（4）

![img](D:\www\better_study_for_golang\每日一题\images\efe061c2ae8ae6c75b4f36bfd766d60471b4bc985cb330cdae5805043b19f440-Picture5.png)

（5）

![img](D:\www\better_study_for_golang\每日一题\images\987e1803a3600ef2b8e18320589e058e189888fb4d88389527f33499340f149a-Picture6.png)

（6）

![img](D:\www\better_study_for_golang\每日一题\images\3850986482cd6344935ac823e8b396b52f02ae196b573cea1e7ebecb97eb063c-Picture7.png)

（7）

![img](D:\www\better_study_for_golang\每日一题\images\cb14268630fd9efa872f077ee625f8066cd7c818f11df9fc9436fa371994de8a-Picture8.png)

（8）

![img](D:\www\better_study_for_golang\每日一题\images\24d94f730e0a7fc091ab321349c4524dd51828db1fa6a9c1b6455561fa27708e-Picture9.png)


## 复杂度分析：

- 时间复杂度O(MN) ： 其中M,N 分别为树A和 树B的节点数量；先序遍历树A占用O(M) ，每次调用 `recur(A, B)` 判断占用O(N) 。
- 空间复杂度O(M) ： 当树A和树B都退化为链表时，递归调用深度最大。当M≤N 时，遍历树A与递归判断的总递归深度为 M ；当 M>N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。



## 代码：

```
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isSubStructure(A *TreeNode, B *TreeNode) bool {

}
```

