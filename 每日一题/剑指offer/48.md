# 剑指 Offer 48. 最长不含重复字符的子字符串

## 题目描述

请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

### 示例:

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

### 限制：

```
s.length <= 40000
```

## 解题思路：

长度为 N 的字符串共有 `(1+N)N/2`个子字符串（复杂度为 `O(N^2)`），判断长度为 N 的字符串是否有重复字符的复杂度为 `O(N)` ，因此本题使用暴力法解决的复杂度为 `O(N^3)` 。考虑使用动态规划降低时间复杂度。

**动态规划解析：**

- 状态定义： 设动态规划列表 dp ，`dp[j]` 代表以字符 `s[j]` 为结尾的 “最长不重复子字符串” 的长度。

- 转移方程： 固定右边界 j ，设字符 `s[j]` 左边距离最近的相同字符为s[i] ，即`s[i]=s[j]` 。

  - 当 i<0 ，即 s[j] 左边无相同字符，则 `dp[j]=dp[j−1]+1` ；

  - 当 `dp[j−1]<j−i` ，说明字符 `s[i]` 在子字符串`dp[j−1]` **区间之外** ，则 `dp[j]=dp[j−1]+1` ；

  - 当 `dp[j−1]≥j−i` ，说明字符 `s[i]` 在子字符串 `dp[j−1]` **区间之中** ，则`dp[j]`的左边界由`s[i]`决定，即 `dp[j]=j−i` ；

  - 当 i<0 时，由于`dp[j−1]≤j` 恒成立，因而`dp[j−1]<j−i` 恒成立，因此分支 1. 和 2. 可被合并。

    ![1616661563302](D:\www\better_study_for_golang\每日一题\images\1616661563302.png)
    	

- 返回值： `max(dp)` ，即全局的 “最长不重复子字符串” 的长度。

![Picture1.png](D:\www\better_study_for_golang\每日一题\images\c576757494724070d0c40cd192352ef9f48c42e14af09a1333972b9d843624a3-Picture1.png)



空间复杂度优化：

- 由于返回值是取dp列表最大值，因此可借助变量 tmp 存储dp[j] ，变量res每轮更新最大值即可。
- 此优化可节省dp列表使用的O(N)大小的额外空间。

观察转移方程，可知问题为：每轮遍历字符 s[j] 时，如何计算索引 i ？
以下介绍 哈希表 ， 线性遍历 两种方法。

### 方法一：动态规划 + 哈希表

- **哈希表统计**： 遍历字符串s时，使用哈希表（记为 dic ）统计 各字符最后一次出现的索引位置 。

- **左边界 i 获取方式**： 遍历到 s[j] 时，可通过访问哈希表 `dic[s[j]]` 获取最近的相同字符的索引 i 。

  (1)

![img](D:\www\better_study_for_golang\每日一题\images\cb0dcc10288d513379da10134c3ce1f9d57f04f975071d29feffb3818131bead-Picture3.png).

(2)

![img](D:\www\better_study_for_golang\每日一题\images\9f4d382dbcde01d659a3b42e4f79412b0d465736664cd84ab32960ede52c70db-Picture5.png)

(3)

![img](D:\www\better_study_for_golang\每日一题\images\2ca3b3f651023b04937ebca4aeaa037ee2735c16044cb114e4779a9b7d5710c0-Picture6.png)

(4)

![img](D:\www\better_study_for_golang\每日一题\images\566742b9e54d09e4db35b745f61cc2fcb5e2ff4c9367124396a48293c70acaf6-Picture7.png)

(5)

![img](D:\www\better_study_for_golang\每日一题\images\2fdcc0106d69d72b32883c3994a5f9da5890678cdfa0e676eafd742090de7957-Picture9.png)

(6)

![img](D:\www\better_study_for_golang\每日一题\images\349014fd22c1d247405706e75a6dbefc5ddcb65f64cc75f343d841dc81584cab-Picture10.png)

### 方法二： 双指针 + 哈希表

本质上与方法一类似，不同点在于左边界 ii 的定义。

- 哈希表 dic统计： 指针 j 遍历字符s ，哈希表统计字符s[j] 最后一次出现的索引 。
- 更新左指针 i ： 根据上轮左指针 i 和 `dic[s[j]]` ，每轮更新左边界 ii ，保证区间 `[i+1,j]` 内无重复字符且最大。`i=max(dic[s[j]],i)`
- 更新结果 res ： 取上轮res 和本轮双指针区间 `[i+1,j]` 的宽度（即 j−i ）中的最大值。
  res=max(res,j−i)





## 复杂度分析：

### 方法一：动态规划 + 哈希表

- 时间复杂度O(N) ： 其中N为字符串长度，动态规划需遍历计算 dp 列表。
- 空间复杂度 O(1) ： 字符的 ASCII 码范围为 0 ~ 127 ，哈希表dic 最多使用 O(128) = O(1) 大小的额外空间。

## 方法二： 双指针 + 哈希表

同方法1



## 代码：

方法一：动态规划 + 哈希表

```
package main

import "fmt"

func lengthOfLongestSubstring(s string) int {
	dic := map[byte]int{}
	var res, tmp int
	for j := 0; j < len(s); j++ {
		i, ok := dic[s[j]] // 获取索引 v
		if !ok {
			i = -1
		}
		dic[s[j]] = j // 更新哈希表
		if tmp < j-i {
			tmp++
		} else {
			tmp = j - i
		}
		res = max(res, tmp) // max(dp[j - 1], dp[j])
	}
	return res
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}

func main() {
	fmt.Println(lengthOfLongestSubstring("au"))
}

```

方法二： 双指针 + 哈希表

```
package main

import "fmt"

func lengthOfLongestSubstring(s string) int {
	dic := map[byte]int{}
	var res int
	i := -1
	var ok bool
	for j := 0; j < len(s); j++ {
		_, ok = dic[s[j]] // 获取索引 v
		if ok {
			i = max(dic[s[j]], i)
		}
		dic[s[j]] = j // 更新哈希表
		res = max(res, j - i) // 更新结果
		ok = false
	}
	return res
}
func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}

func main(){
	fmt.Println(lengthOfLongestSubstring("au"))
}
```

