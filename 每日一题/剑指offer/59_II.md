# 剑指 Offer 59 - II. 队列的最大值

## 题目描述

请定义一个队列并实现函数 `max_value` 得到队列里的最大值，要求函数`max_value`、`push_back` 和 `pop_front` 的均摊时间复杂度都是O(1)。

若队列为空，`pop_front` 和 `max_value` 需要返回 -1

### 示例:

```
输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]


输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]
```

### 限制：

```
1 <= push_back,pop_front,max_value的总操作数 <= 10000
1 <= value <= 10^5
```

## 解题思路：

> 对于普通队列，入队 `push_back()` 和出队 `pop_front()` 的时间复杂度均为O(1) ；本题难点为实现查找最大值 `max_value()` 的O(1) 时间复杂度。
> 假设队列中存储N个元素，从中获取最大值需要遍历队列，时间复杂度为O(N) ，单从算法上无优化空间。

如下图所示，**最直观的想法是维护一个最大值变量** ，在元素入队时更新此变量即可；但当最大值出队后，并无法确定下一个 **次最大值** ，因此不可行。

![Picture1.png](http://cdn.xiaot123.com/blog/2021-04/1609261470-WanZuG-Picture1.png-blog)

考虑利用 **数据结构** 来实现，即经常使用的 “空间换时间” 。如下图所示，考虑构建一个**递减列表**来保存队列 **所有递减的元素** ，递减链表随着入队和出队操作实时更新，这样队列最大元素就始终对应递减列表的首元素，实现了获取最大值`O(1)`时间复杂度。

![Picture2.png](http://cdn.xiaot123.com/blog/2021-04/1609261470-gMTEAf-Picture2.png-blog)

为了实现此递减列表，需要使用**双向队列** ，假设队列已经有若干元素：

1. 当执行入队 `push_back()` 时： 若入队一个比队列某些元素更大的数字x ，则为了保持此列表递减，需要将双向队列 **尾部所有小于x的元素** 弹出。
2. 当执行出队 `pop_front()` 时： 若出队的元素是最大元素，则 双向队列 需要同时 将**首元素出队** ，以保持队列和双向队列的元素一致性。

> 使用双向队列原因：维护递减列表需要元素队首弹出、队尾插入、队尾弹出操作皆为 O(1)O(1) 时间复杂度。

**函数设计**：

初始化队列 queue ，双向队列 deque ；

**最大值 max_value()** ：

1. 当双向队列 `deque` 为空，则返回 -1 ；
2. 否则，返回 `deque` 首元素；

**入队 push_back()** ：

1. 将元素 `value` 入队 `queue` ；
2. 将双向队列中队尾 所有小于 `value` 的元素弹出（以保持 `deque` 非单调递减），并将元素 value 入队 deque ；

**出队 pop_front()** ：

1. 若队列 queue 为空，则直接返回 −1 ；
2. 否则，将 queue 首元素出队；
3. 若 deque 首元素和 queue 首元素 相等 ，则将 deque 首元素出队（以保持两队列 元素一致 ） ；

> 设计双向队列为**单调不增**的原因：若队列 `queue` 中存在两个 `值相同的最大元素` ，此时 queue 和 deque 同时弹出一个最大元素，而 queue 中还有一个此最大元素；即采用单调递减将导致两队列中的元素不一致。

(1)

![img](http://cdn.xiaot123.com/blog/2021-04/1609261619-bCHZki-Picture4.png-blog)

(2)

![img](http://cdn.xiaot123.com/blog/2021-04/1609261619-VJHbWU-Picture5.png-blog)

(3)

![img](http://cdn.xiaot123.com/blog/2021-04/1609261619-TeDGxf-Picture7.png-blog)

(4)

![img](http://cdn.xiaot123.com/blog/2021-04/1609261619-xvlryq-Picture8.png-blog)

(5)

![img](http://cdn.xiaot123.com/blog/2021-04/1609261619-ARzNSA-Picture9.png-blog)



## 复杂度分析：

- 时间复杂度 O(1)： `max_value()`, `push_back()`, `pop_front()` 方法的均摊时间复杂度均为 `O(1)`；
- 空间复杂度 O(N)： 当元素个数为 N 时，最差情况下deque 中保存 N 个元素，使用 `O(N)`的额外空间；

## 代码：

```
package main

type queue struct{
	arr []int
}

func (q *queue) isEmpty() bool {
	return len(q.arr) == 0
}

type MaxQueue struct {
	Queue *queue
	Deque *queue
}

// 返回队首元素
func (q *queue) Front() int {
	if len(q.arr) == 0 {
		return -1
	}
	return q.arr[0]
}
// 返回队尾元素
func (q *queue) Back() int {
	if len(q.arr) == 0 {
		return -1
	}
	return q.arr[len(q.arr)-1]
}
// 队首删除元素
func (q *queue) DeQue() int {
	if len(q.arr) == 0 {
		return -1
	}
	re := q.arr[0]
	if len(q.arr) > 1 {
		q.arr = q.arr[1:len(q.arr)]
	} else {
		q.arr = []int{}
	}
	return re
}

// 队尾删除元素
func (q *queue) Pop() int {
	if len(q.arr) == 0 {
		return -1
	}
	re := q.arr[len(q.arr)-1]
	if len(q.arr) > 1 {
		q.arr = q.arr[:len(q.arr)-1]
	} else {
		q.arr = []int{}
	}
	return re
}

// 队列加入元素
func (q *queue) EnQue(nums int) {
	q.arr = append(q.arr, nums)
}


func Constructor() MaxQueue {
	return MaxQueue{
		Queue:&queue{[]int{}},
		Deque:&queue{[]int{}},
	}
}


func (this *MaxQueue) Max_value() int {
	if this.Deque.isEmpty() {
		return -1
	}
	return this.Deque.Front()
}


func (this *MaxQueue) Push_back(value int)  {
	this.Queue.EnQue(value)
	for !this.Deque.isEmpty() && this.Deque.Back() < value{ // 注意这里是小于 不是小于等于
		this.Deque.Pop()
	}
	this.Deque.EnQue(value)
}


func (this *MaxQueue) Pop_front() int {
	if this.Queue.isEmpty() {
		return -1
	}
	val := this.Queue.Front()
	if val == this.Deque.Front() {
		this.Deque.DeQue()
	}
	this.Queue.DeQue()
	return val
}




/**
 * Your MaxQueue object will be instantiated and called as such:
 * obj := Constructor();
 * param_1 := obj.Max_value();
 * obj.Push_back(value);
 * param_3 := obj.Pop_front();
 */

```

