# 剑指 Offer 46. 把数字翻译成字符串

## 题目描述

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

### 示例:

```
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

### 限制：

```
0 <= num < 2^31
```

## 解题思路： 

根据题意，可按照下图的思路，总结出 “递推公式” （即转移方程）。
因此，此题可用动态规划解决，以下按照流程解题。

![Picture1.png](http://cdn.xiaot123.com/blog/2021-04/e231fde16304948251633cfc65d04396f117239ea2d13896b1d2678de9067b42-Picture1.png-blog)



**动态规划解析**：

> 记数字num第 i 位数字为 x_i，数字 num 的位数为 n ；
> 例如：num=12258 的 n=5 , x_1 = 1 。

- 状态定义： 设动态规划列表`dp` ，`dp[i]` 代表以 `x_i`为结尾的数字的翻译方案数量。
- 转移方程： 若 `x_i`和 `x_{i-1}`组成的两位数字可以被翻译，则 `dp[i]=dp[i−1]+dp[i−2]`（**这里的推导可以联想一下斐波那契数列以及青蛙跳台阶**） ；否则 `dp[i]=dp[i−1]`。
  - 可被翻译的两位数区间：当 `x_{i-1} = 0`时，组成的两位数是无法被翻译的（例如 00, 01, 02, ⋯ ），因此区间为 `[10, 25]` 。
  - ![1617161200176](http://cdn.xiaot123.com/blog/2021-04/1617161200176.png-blog)
- 初始状态：`dp[0]=dp[1]=1` ，即 “无数字” 和 “第 11 位数字” 的翻译方法数量均为1 ；
- 返回值： `dp[n]` ，即此数字的翻译方案数量。



> Q： 无数字情况dp[0]=1 从何而来？
> A： 当num 第1,2 位的组成的数字 ∈[10,25] 时，显然应有 2 种翻译方法，即 dp[2]=dp[1]+dp[0]=2 ，而显然dp[1]=1 ，因此推出 dp[0]=1 。

**字符串遍历**

- 为方便获取数字的各位 `x_i`，考虑先将数字num 转化为字符串s ，通过遍历s实现动态规划。
- 通过字符串切片`s[i−2:i]` 获取数字组合 `10 x_{i-1} + x_i` ，通过对比字符串 ASCII 码判断字符串对应的数字区间。
- 空间使用优化： 由于dp[i] 只与dp[i−1] 有关，因此可使用两个变量a,b 分别记录 `dp[i],dp[i−1]` ，两变量交替前进即可。此方法可省去dp列表使用的O(N) 的额外空间。

(1)

![img](http://cdn.xiaot123.com/blog/2021-04/f61ef2e376f0630ac9cf7cbd50701e64f73c9eb780bd942bd0697b92e3e13483-Picture2.png-blog)

(2)

![img](http://cdn.xiaot123.com/blog/2021-04/ad781beae643580cd3d52cca8679799deb3f7507d899881103bbe21a3f38907c-Picture3.png-blog)

(3)

![img](http://cdn.xiaot123.com/blog/2021-04/65d0dd59b5c6d31908f9f3df9a5f4282c94b58823a85339662fde39f9e649bd9-Picture4.png-blog)

(4)

![img](http://cdn.xiaot123.com/blog/2021-04/c13a47704f2f533c98a6c4175cacb858d54fd193fb9fec0f39e5f7b8d7735e4c-Picture9.png-blog)

(5)

![img](http://cdn.xiaot123.com/blog/2021-04/46d1fbb9a5943ddc56a48fa52d90447f4cf19467d67e6a44ae9b04dbc9804841-Picture10.png-blog)

(6)

![img](http://cdn.xiaot123.com/blog/2021-04/931cfb6eebc6b28ce255a4519a7cfa4ceee112ead044f4fc61f1eda46f13b9d7-Picture11.png-blog)


## 复杂度分析：

时间复杂度 O(N) ： N 为字符串 s 的长度（即数字 num 的位数 log(num) ），其决定了循环次数。
空间复杂度O(N) ： 字符串 s 使用 O(N) 大小的额外空间。



## 代码：

```
package main

import (
	"fmt"
	"strconv"
)

func translateNum(num int) int {
	str := strconv.Itoa(num)
	a := 1
	b := 1
	c := 0
	for i := 2; i <= len(str); i++ {
		newnum := str[i-2 : i]
		if newnum >= "10" && newnum <= "25" {
			c = a + b
		} else {
			c = a
		}
		b = a
		a = c
	}
	return a
}

func main() {
	fmt.Println(translateNum(12258))
}
```

